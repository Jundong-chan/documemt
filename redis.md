#### 使用的好处

(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

(2) 支持丰富数据类型，支持string，list，set，sorted set，hash

(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除



#### **redis相比memcached有哪些优势？**：

#### **参考答案**：

(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型

(2) redis的速度比memcached快很多

(3) redis可以持久化其数据



#### redis常见性能问题和解决方案

#### **参考答案**：

(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件

(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内

(4) 尽量避免在压力很大的主库上增加从库

(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1 <- Slave2 <- Slave3...

这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。



#### MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据

#### **参考答案**：

相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：

voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据



#### Memcache与Redis的区别都有哪些？

#### **参考答案**：

1)、存储方式

Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。

Redis有部份存在硬盘上，这样能保证数据的持久性。

2)、数据支持类型

Memcache对数据类型支持相对简单。

Redis有复杂的数据类型。

3)、使用底层模型不同

它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。

Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

4），value大小

redis最大可以达到1GB，而memcache只有1MB



#### Redis的同步机制了解么？

主从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。



#### 是否使用过Redis集群，集群的原理是什么？

#### **参考答案**：

Redis Sentinel着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。



#### redis会遇到的问题：缓存穿透

场景：平时的缓存方案，数据库存一份，缓存存一份，当缓存有数据，直接从缓存中取，如果缓存没有，则从数据库中取，然后拷一份到缓存。

什么是缓存穿透：当缓存和数据库中都没有的数据的时候，大量的请求会直接到数据库中请求数据，如果出现恶意大量请求，会导致数据库挂掉

解决方式：

1、增加过滤器，过滤非法的请求。布隆过滤器，底层维护着一个超大的bit map，将数据库中可能的字段映射到map上，查询的时候先到 布隆过滤器 查看是否命中。 缺点1: **布隆过滤器可能存在hash 碰撞（误差）**，导致一些不存在的请求字段能够命中，但是 未命中的字段一定不在数据库中。 缺点2：**布隆过滤器的底层数据无法删除。**优点：省内存，hash转向量也方便。向量存在bitmap.

2、缓存空值，如果在数据库中访问不到的数据，就在缓存中缓存一个几分钟内就会过期的空值，这样那些恶意的请求会回到缓存中访问到空值。



bitmap解释：redis也有bitmap数据类型。

bitmap实际上是用比特位来存储数字，比如0000000100101001  这个bitmap存储了数字0，3，5 注意是同时存储了。如果 使用3个int型的变量来存储这三个数字，会比较耗费空间。

底层实现，实际上 将一个64位的long型的变量作为一个word ，然后每次新创建一个bitmap 会有 4*64个bit也就是 4个word，然后第一个word往往不存实际的数据，低32位存放当前的word前面横跨了多少个空的word ，高32位存放后方有多少个连续的存储数据的word。

这样的好处是省存储内存，如果存放几个很小的数据，然后突然要存放几个超级大的数据，那么大的数据和小数据之间不需要创建这么多的空word，横跨了多少，具体数据存储在 四个word的中的第一个word。

使用场景：常用于对大量的数据进行去重（将数据放入bitmap中，当发现bit位已经为1则相当于做了去重。）和查询，还可以查询并集和交集（将两个bitmap做位运算）

还可以做用户的状态记录，比如365天打卡记录，一周内的出勤天数等

[参考](https://www.sohu.com/a/300039010_114877)

#### redis会遇到的问题：缓存击穿

场景：当某个数据本来在数据库中是存在的，但是缓存中没有（一般是缓存失效了）。如果是热点数据，大量的请求没有命中缓存而是到数据库中请求，则会导致数据库承受巨大压力。

解决方式：

1、如果是热点数据可以考虑设置永远不过期。

2、在缓存中未命中，然后请求数据库的时候，设置一个锁，去访问，得到数据后将数据放到缓存，然后解开锁。注意如果访问失败了也要记得解开锁。



#### redis会遇到的问题:  缓存雪崩

场景：缓存中有大量的数据在短时间内都要过期，在过期后数据库的压力也会激增。

解决方式：

1、如果是热点数据，设置永远不过期。

2、将数据的过期时间错开，让缓存失效时间尽量均匀

3、备份双层缓存，两个缓存的过期时间不一样

4、分布式锁？set key value ex 时间 nx



#### redis集群，多主多从

扩展了redis内存，不受单机的限制，高可用。

如何实现数据请求精准打到指定的服务器上，而 服务器的上下线不会影响到数据的后续存储。

redis使用了类似一致性hash的算法，把缓存的key hash分配到 16384个槽之中，当往Redis Cluster中加入一个Key时，会根据crc16(key) mod 16384计算这个key应该分布到哪个hash slot中，**一个hash slot中会有很多key和value。可以理解成表的分区**，使用单节点时的redis时只有一个表，所有的key都放在这个表里；改用Redis Cluster以后会自动生成16384个分区表，你insert数据时会根据上面的简单算法来决定key应该存在哪个分区，每个分区里有很多key。



在cluster模式下，节点对请求的处理过程如下：

1. 检查当前key是否存在当前节点
   1）通过crc16（key）/16384计算出slot
   2）查询负责该slot负责的节点，得到节点指针
   3）该指针与自身节点比较
2. 若slot不是由自身负责，则返回MOVED重定向
3. 若slot由自身负责，且key在slot中，则返回该key对应结果
4. 若key不存在此slot中，检查该slot是否正在迁出
5. 若key正在迁出，返回ASK错误重定向客户端到迁移的目的服务器上
6. 若slot未迁出，检查slot是否导入中？
7. 若slot导入中且有ASKING标记，则直接操作
8. 否则返回MOVED重定向

每个客户端可以随便发起请求到集群中的任意一个节点，包括从节点。节点将会解析请求并计算该key对应slot是否由该节点负责，若不是由该节点负责的槽则返回一个MOVED错误。



#### 为什么不使用一致性hash而使用hash槽

因为hash槽实现简单，节点的增删处理起来方便，只需要将槽分配或者移动到新的节点就可以了。



#### redis的集群结构

无中心结构，每个节点保存数据的集群的状态，并且每个节点和其他节点都有所连接。



#### 主从复制的过程

从机发送sync命令到主机，然后主机 执行 bigsave 进行异步保存，备份数据，期间主机收到的写命令都会缓存起，和备份数据一起发送给从机；从机执行完后，主机后续收到的写命令都会发送给从机执行。



#### 哨兵机制

- 监控，哨兵会不断检查主节点和从节点的运行是否正常。
- 自动故障转移，当一个主节点挂机的时候，会选举出新的主节点，然后让其他的从节点对它进行复制。
- 配置提供，客户端初始化后，通过向哨兵查询当前服务结构的主节点地址。
- 通知：哨兵可以将故障转移的结果发送给客户端。

- 选举使用的是raft算法，服务节点之间通过rpc通信。


#### 缓存和数据库双写一致性问题

实际上缓存和数据库很难严格保持一致性。

读的时候，先读缓存，缓存没有，读数据库，再把数据放到缓存。

写的时候，先删缓存，再更新数据库。

为什么是删而不是更新？因为这个缓存可能读取的次数不多，但是每次修改都需要更新缓存，和 在读的时候才更新上来，两种消耗的更改次数是不同的，这里使用懒加载的思想比较好。

先删缓存，如果失败，就不更新数据库，这样还是一致的。更新数据库失败，那数据库里剩旧的数据，也不会导致不一致。



如果先更新数据库，再删除缓存（缓存删除失败），也会导致数据不一致，怎么解决？



我的秒杀库存采用的是先更新缓存，再使用 消息队列异步更新数据库。由于数据需要频繁更改，所以只能先在缓存中更改数据。这种做法没有保证强一致性。主要原因是 库存很有可能在几秒钟之内清空，所以。



#### 问：先删除缓存，在写数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致，怎么处理？

使用消息队列，对数据库的读写操作使用消息队列，那么写数据库的消息排在 读数据库的请求后面，就保证了先后。



#### 如何实现分布式锁

使用redis 的 set key value ex 时间  nx

尝试设置一个key 的过期时间，如果设置成功则说明能获得锁。



#### 锁超时了把别人给删除了怎么办

将value的值加入请求的id 以及 过期时间，在超时结束的时候，先get 一下key，看看内容是不是自己之前锁上的内容，如果是则可以删除，如果不是，则说明锁别人已经拿去用了。



#### 分布式锁保证可重入性

可重入性指的是：当这个线程已经获得锁了，线程内部可以再次对这个锁进行上锁。

先尝试获取锁。获取失败，就读取锁，看看是不是自己线程的。

设置value的时候，json 字符串里加一个 count ，上锁的时候，读取这个锁的id 和count 如果count =0则进行加锁，id和自己的id相等，则给count+1然后直接使用锁。



#### 为什么使用消息队列

**异步，削峰，解耦**

异步：有一个业务处理流程，需要经过多个子系统的调用执行完才返回结果。 可以使用异步，将调用其他子系统的请求放到消息队列中，让他们慢慢处理，主系统直接返回结果就可以了，加快了响应速度。

削峰：在请求量瞬间增大的时候，怎么承接大流量保证系统不垮掉，使用消息队列承接请求。然后可以设置每秒接收处理多少请求，达到限流效果。



为什么你的系统没有使用mq来处理请求？

因为本来考虑到请求量没有特别大，所以先使用了redis 的list进行处理。性能怎么样？使用postman进行了接口测试，

因为 使用redis的list也可以对请求进行缓冲，虽然性能可能没有mq那么好，但是可以



#### 怎么保证消息队列高可用

创建多个副本就好了。



#### 怎么保证消息的消费不会重复（幂等性）

幂等性：同一个请求不管连续执行多少次，返回的结果都是一样的。

对消息队列进行id编号。





#### 消息队列的优缺点

优点：解耦，异步，削峰

缺点：系统可用性降低（mq可能会挂，需要设置集群来保证高可用），复杂度升高，一致性降低。



#### 怎么保证消息不丢失，不重复，执行的顺序性

消息丢失场景：生产者没有成功将消息发送给MQ broker 。服务器下线了。

MQ在收到消息后还没持久化，就宕机了。

发送消息后，消费方没有处理到就宕机了。

解决：可靠投递，mq收到消息后需要给出确认。收到消息后进行持久化，消费方在拿到消息处理成功后返回确认，mq就可以把数据删除。



保证消息幂等（不重复执行）

场景：发送的时候，网络不可达，重复发送消息，消费者由于网络原因，收到重复的消息。

解决：写入一个全局的id放到消息，当消费方拿到消息，先到redis或者db中查找消息是否被消费过，没有处理过，则先消费，然后把id存进redis或db



执行的顺序性：

消息需要保证顺序性才不会出错。

生产者将同一组消息发送到同一个队列，加锁来保证消息的顺序性。





#### 怎么保证数据的一致性

通过分布式事务来保证多个消息队列之间执行的成功。

分布式事务：当一个业务的操作逻辑需要操作不同的数据库的时候，要保证这些操作要么成功要么失败。

由于数据库变成分布式，需要保证不同数据库的一致性。

解决：消息的发送方先处理自己的逻辑，当需要调用的时候，就生成一个消息，先本地保存，然后发送给消费者，然后消费方查询消息是否被执行过，然后执行，成功或者失败都会发送一个通知消息给mq，生产者收到后，如果成功则删除本地对应消息，如果失败，就再将本地消息发送过去。





#### kafka总结

是一种消息队列，主要用于 分布式系统中的 服务之间的解耦（通过消息队列来处理消息，等待结果），异步（发送给消息队列后就可以返回了），系统请求的削峰。

**有两种模式**：1、是发布订阅模式，将消费者订阅的消息推送给他。

2、一对一模式，消费者主动到mq里取消息。

Topic 队列，一个topic中有很多个 partition(分区)，同topic的消息都会被送到 分区里，每个group 里只有一个消费者能从一个分区拿东西 ，每个partition 按照顺序处理消息，一个broker可以容纳多个topic

**无论消息是否被消费**，kafka都会保存所有消息，到硬盘。使用的是zookeeper进行消息的管理。



消息保证机制：

1、保证消息传输可能会丢失但不会重复 ：消费者先提交，后处理。

2、保证消息不会丢失，但可能会重复  ：消费者先处理后提交。

#### 一个分区同时只能被一个消费者消费，当消费者位于不同的组，可以同时消费到同一个partition内的数据。

[参考](https://www.cnblogs.com/sa-dan/p/8080197.html)

应用场景：

收集日志：一个公司可以用Kafka可以收集各种服务的log，通过kafka以统一接口服务的方式开放给各种consumer；



为什么kafka使用磁盘速度还快？

1、当生产者发送数据过来的时候，消息是追加到 partition末尾的，也就是partition 文件的末尾。利用了磁盘的顺序读写，速度快。

2、消费者在读取数据的时候，是带有读取偏移量的，因此可以直接使用顺序读取。

写入和读取相当于直接在网络层到内核，在内核空间进行读写数据，所以快。



#### Redis 字符串底层实现

是由自定义的字符动态数组实现的，本质是一个字符数组，并且有length 和 free来维护。

不需要担心缓冲区溢出，可以使用o1复杂度获取数据，



#### Redis list底层实现

双向链表，底层实现是 使用一个数组 存所有的key , 然后 每个 key 使用链表的形式存储 key中存的map

扩容机制

Redis的有序集合、哈希以及列表都直接或者间接使用了压缩列表。当有序集合或哈希的元素数目比较少，且元素都是短字符串时，Redis便使用压缩列表作为其底层数据存储方式。

在3.2版本之前，当数据量少的时候使用 ziplist （512个以内数据量以及每个元素的大小不超过64字节）

不满足时则使用双向链表。

在3.2版本之后直接使用quiklist 

也就是一个链表，节点指向一个ziplist. 相当于将 ziplist和双向链表结合。ziplist是连续的存储空间。



#### Redis set 底层原理

数据元素量小于512时使用inset结构，按顺序编码好的动态数组，查找使用二分，数据量大的时候转换成ha shmap



#### Redis zset底层实现

当数据量比较少的时候使用ziplist，数值从小到大。

换跳表和字典存储。 先到字典进行O(1)查找，找到key对应的 ，然后到链表中找到对应的值就可以了。

去重。







#### 做限流

使用 消息队列

使用 ratelimiter  使用了 令牌桶算法

令牌桶算法：请求的流量以不定速率申请资源，程序处理请求，以固定速率来处理，阻塞的请求会等待超时间，或者立即返回。





#### Raft 算法

动态图解算法

[链接](http://raft.taillog.cn/)

